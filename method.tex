\chapter{材料与方法}


% Drawing part, node distance is 1.5 cm and every node
% is prefilled with white background
\begin{tikzpicture}[
        node distance=1cm,
        every node/.style={fill=white, font=\sffamily},
        align=center
    ]
    % Specification of nodes (position, etc.)
    \node (start) [terminalStart] {开始};
    \node (firstSampling) [data, below left=of start, xshift=-3cm] {对 70 个 Cotton2K \\参数进行 Sobol 取样};
    \node (fieldData) [data, below=of start, yshift=-1.5cm] {田间数据};
    \node (firstSimulation) [process, below=of firstSampling, yshift=-1.5cm] {Cotton2K 模拟};
    \node (firstDatabase) [data, below=of firstSimulation] {12 个输出变量的\\评价指标数据库};
    \node (sa) [process, below=of firstDatabase] {使用 SALib 进行\\Sobol 全局敏感性分析};
    \node (influential) [decision, below=of sa] {S1 > 0.05};
    \node (fixParam) [process, below=of start, yshift=-10cm] {固定参数为默认值};
    \node (secondSampling) [data, below right=of start, xshift=3cm] {对 35 个 Cotton2K \\参数进行 Sobol 取样};
    \node (secondSimulation) [process, below=of secondSampling, yshift=-1.5cm] {Cotton2K 模拟};
    \node (secondDatabase) [data, below=of secondSimulation] {12 个输出变量的\\评价指标数据库};
    \node (moo) [process, below=of secondDatabase] {求解 Pareto 解集};
    \node (prune) [process, below=of moo] {对 Pareto 解集进行剪枝};
    \node (compare) [process, below=of prune] {对不同修改进行统计分析};
    \node (stop) [terminalStop, below=of start, yshift=-11.7cm] {结束};

    \draw [-latex] (start) -| (firstSampling);
    \draw [-latex] (firstSampling) -- (firstSimulation);
    \draw [-latex] (firstSimulation) -- (firstDatabase);
    \draw [-latex] (firstDatabase) -- (sa);
    \draw [-latex] (sa) -- (influential);
    \draw [-latex] (influential.east) -- (fixParam) node[pos=0.5, inner sep=0]{否};
    \draw [-latex] (influential.west) -- +(-1.5cm,0) node[pos=0.5, inner sep=0]{是} -- +(-1.5cm, 13cm) -| (secondSampling);
    \draw [-latex] (secondSampling) -- (secondSimulation);
    \draw [-latex] (secondSimulation) -- (secondDatabase);
    \draw [-latex] (secondDatabase) -- (moo);
    \draw [-latex] (moo) -- (prune);
    \draw [-latex] (prune) -- (compare);
    \draw (fieldData) -| (firstSimulation);
    \draw (fieldData) -| (secondSimulation);
    \draw [-latex] (fixParam) |- (secondSimulation);
    \draw [-latex] (compare) -- (stop);
\end{tikzpicture}



\section{实验观测}
试验区位于南疆地区阿拉尔市塔里木大学灌溉试验站 (\ang{81;11;46}E, \ang{40;37;28}N)。
\begin{figure}
    \centering
    \includegraphics[scale=0.4]{research_site.png}
    \caption{试验站所在位置}
\end{figure}
灌溉实验按照田间实验设计，采用滴灌方式，根据 SWAP 模型\cite{swap2021}的精准灌溉工具，通过气象数据，土壤数据和棉花生长数据计算每日的实际蒸发蒸腾量 ($ET_c$)，按照水分需求进行灌溉。
设计三个灌溉水平，标准亏损灌溉 75\% $ET_c$，90\% $ET_c$ 和 100\% $ET_c$。
另外，设计一个经验灌溉水平，灌溉定额 $\mathrm{280 m^3 / 667m^2}$，生育期滴水总计 14 次。
项目中不研究其他营养对棉花生长的影响，所以 N、P、K 肥按照经验值随滴灌施入，测土施肥，各小区施肥量统一，$N$-$P_2O_5$-$K_2O$ 按照 250-100-50 $\mathrm{kg/hm^2}$ 的量进行施肥。
播种日期设计 2 个水平，分别为铺设地膜的棉花播种后第 10 和 15 天，根据出苗率补充到设计的种植密度，并记录补苗日期。
第一年设计三个种植密度，理论密度分别为 15000, 16000 和 17000 株/$\mathrm{hm^2}$。
第二年到第三年根据第一年的模拟结果进行适当调整。
共 24 个处理，进行安全区组设计，每个小区 0.25 亩，每个实验三次重复。

\subsection{气象数据}

该模型所需的每日气象数据包括太阳辐射 ($langley$)，最高和最低温度 (℃) 和降水 (mm) 以及2米高度的风速 (km/h)。

\begin{table}
    \caption{Cotton2K 模型所需输入每日气象数据}\label{tab:meteorology}
    \small
    \centering
    \begin{tabular}{cccc}
        \toprule
        名称         & 解释                     & 单位                                              & 是否必须 \\
        \midrule
        太阳辐射强度 & 大气下垫面短波辐射强度   & $\mathrm{langley} = 0.04184\ \mathrm{MJ\ m^{-2}}$ & 是       \\
        最高气温     & 2 m 最高气温             & ℃                                                 & 是       \\
        最低气温     & 2 m 最低气温             & ℃                                                 & 是       \\
        露点温度     & 空气冷却达到饱和时的温度 & ℃                                                 & 否       \\
        降水         & 24 小时内降水            & mm                                                & 是       \\
        风速         & 2 m 风速                 & km/h                                              & 否       \\
        \bottomrule
    \end{tabular}
\end{table}

当露点温度不可得时，可通过公式 \ref{eq:dewpoint} 估算而得。

\begin{equation}\label{eq:dewpoint}
    T_{dew} = \begin{cases}
        SitePar_5                                                            & T_{\max} < 20        \\
        \frac{(40 - T_{\max}) * SitePar_5 + (T_{\max} - 20) * SitePar_6}{20} & 20 \le T_{\max} < 40 \\
        SitePar_6                                                            & T_{\max} \ge 40      \\
    \end{cases}
\end{equation}

式中，$T_{dew}$ 为露点温度 (℃)，$T_{\max}$ 为最高气温 (℃)，$SitePar_5$ 与 $SitePar_6$ 为用户提供输入，与试验站相关。

当每日风速数据不可得时，使用年平均风速代替。

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{climate.png}
    \caption{2019-2021年试验站棉花生长期主要气象数据}
\end{figure}

冠层温湿度由精创 RC-4HA 收集，设置取样间隔为 0.5 小时。

\subsection{光能截获率}

在2019年使用LI-6400XT便携式光合作用系统，在2020年使用 LI-191R 线量子传感器和 LI-1500 光传感器在每10天的晴天中午13点至15点之间收集光截获数据。
行内空间被划分为网格，5个水平列和根据植物高度分为6层，每个网格的宽度相等，高度为 20 厘米，然后用设备测量每个网格的照度。
光截获量的计算方法是：同一水平层中各网格的平均光照度减去比率，参见公式\ref{eq:measured_li}。

\begin{equation}\label{eq:measured_li}
    LI_{i} = 1 - \frac{\sum^5_{j=1} I_{i,j}}{\sum^5_{j=1} I_{i+1,j}} \quad \mathrm{for} i \in {1,2,\dots,6}
\end{equation}

式中， $LI_{i}$ 为第 $i$ 层的光能截获率， $I_{i,j}$ 是第 $i$ 层第 $j$ 列网格的光照强度， $I_{i+1,j}$ 为上层网格的光照强度。

\subsection{土壤含水量与温度}

土壤温度由 Thermochron® iButton®器件(DS1921G) 收集，设置取样间隔为 2 小时。

\subsection{棉花生理指标}
试验记录内容主要包括:
\begin{enumerate}
    \item 生育期：详细记录棉花播种、出苗、现蕾、开花和吐絮期出现时间，均以全田 50\% 棉株达到发育要求为标准；
    \item 株式图：每 10 天记录一次株式图，内容有株高、叶片数、果枝数、果节数、蕾、花、小铃、大铃及吐絮铃个数与部位等；
    \item 叶面积指数和光合有效辐射：每 10 天结合干物质测定，取全株叶片，用扫描法测定冠层垂直方向 20 个深度和水平 8 个网格的叶面积指数。使用 SunScan冠层分析仪（Delta 公司，英国）测定不同垂直和水平方向的光合有效辐射 PAR 和叶面积指数；
    \item 光合作用：每 10 天测试一次，使用 LI6400XT 便携式光合作用测试仪分层测试净光合速率、气孔导度、胞间 CO2 浓度和蒸腾速率以及光响应曲线；
    \item 干物质积累和分配：每 10 天取样一次，每次取样在苗期取 10 株样品，开花期后每次取 5 株，样品在 80℃下烘干至恒重后，分别测定根、茎、叶、蕾、花、小铃和大铃等各器官的干物质重量；
    \item 产量构成因素：测定棉花籽棉产量、衣分、铃重和纤维重量；
    \item 根系：每隔 10 天取样，在 0-100cm 土壤深度和距棉行 0-40cm 内各 5cm间隔分别用根钻取带根土样，冲根器冲洗根后，用扫描仪扫描成 TIF 图像文件，再采用 DT-SCAN 图像分析软件，计算根系长度、密度、直径和表面积等指标；
    \item 土壤水分：每周取样测定一次土壤容积含水量（20 $\times$ 8 网格），另外，使用矫正后的土壤水分和温度自动记录仪 (HOBO H21-002, United States) 分 10 层实时监测 0-100cm 深度的土壤水分含量；
    \item 土壤盐分（电导率）：每周取样在实验室处理后采用 DDS-307 电导率仪测量，折算成土壤盐分含量；
    \item 其他土壤参数：土壤田间持水率、容积密度、枯萎点含水率、饱和土壤含水率、土壤水响应曲线和渗透系数等可直接取样带回实验室进行测量，同步记录灌溉日期和灌溉量；
    \item 土壤蒸发与棉花蒸腾：采用小型蒸渗仪测量蒸发，棉花蒸腾通过水量平衡原理计算；
    \item 气象数据：由塔里木灌溉试验站气象数据提供，包括 15 分钟间隔的温度、湿度、辐射、风速、降雨和气压数据等。
\end{enumerate}

所获数据用 Python 进行统计分析，利用 Duncan 新复极差检验进行差异显著检验 $(p = 0.05)$。

\subsection{棉花水分利用效率}
水分利用效率 (Water use efficiency, WUE) 是节水农业重要指标，高水平的 WUE 是干旱区农业持续发展的关键所在。
WUE 包括灌溉水利用效率，降水利用效率和作物水分利用效率。
由于研究区降水稀少，本文仅分析灌溉水利用效率和作物水分利用效率。

棉花水分利用效率 ($WUE_{ET}$) 和灌溉水分利用效率 ($IWUE$) 计算公式如下：

\begin{equation}
    WUE_{ET} = Y / ET_c
\end{equation}

\begin{equation}
    IWUE = (Y - Y_n) / I
\end{equation}

式中 $Y$ 为皮棉产量 ($\mathrm{kg\ ha^{-1}}$)，
$Y_n$ 为无灌水条件下棉花皮棉产量 ($\mathrm{kg\ ha^{-1}}$)，
$ET_c$ 为生育期棉花蒸散量，
$I$ 为灌水量 (mm)。
\subsection{棉花蒸散量计算}

各处理耗水量采用水量平衡公式计算：

\begin{equation}
    ET_c = R + I - F + Q - S + \Delta W
\end{equation}

式中 $ET_c$ 为作物蒸发蒸腾量 (mm)，
$R$ 为降水量 (mm)，
$I$ 为灌水量 (mm)，
$F$ 为地表径流量 (mm)，考虑到地下埋管滴灌棉田实验期间无地表径流发生，此处取 $F = 0$
$Q$ 为地下水补给量 (mm)，实验资料表明 110 \~ 130 cm 深处土壤水分变化不明显，因此做简化处理，取 $Q = 0$，
$\Delta W$ 为土壤储水变化量 (mm)，
$S$ 为深层渗漏量(mm)，实验田灌水量通过水量平衡方程计算确定，不存在深层渗漏，故 $S=0$；
$\Delta W$ 为土壤贮水量的减少量(mm)：

\begin{equation}
    \Delta W = W_i - W_{i+1}
\end{equation}

式中：$W_i$ 和 $W_{i+1}$ 分别为第 $i$ 个时段初和时段末计划湿润层内的土壤贮水量 (mm)。
为方便水量平衡计算，将含水率换算为以 mm 为单位的土壤贮水量 $W$ ：

\begin{equation}
    W = 10 \cdot \theta \cdot \gamma \cdot h
\end{equation}

式中：$W$ 为土壤贮水量(mm)，$\theta$ 为计划湿润层内土壤质量含水率 (\%)，$\gamma$ 为土壤体积质量 ($\mathrm{g cm^{-3}}$)，$h$ 为计划湿润层深度 (cm)。

\section{模型模拟}
\subsection{模型改进}

分析叶面积指数、叶倾角和方位角的空间分布规律及光能截获分布，冠层深度拟分为 20 层，每层占棉花总高度的 5\%，水平方向根据棉花冠幅考虑 8 个网格，共 160 个冠层空间。
首先，计算每一层的有效叶面积指数，
其次，定量化每一层与最顶部冠层的光合叶面积指数的比例（$PAI_{\%,i}$），重新积分计算有效总光合叶面积指数，
最后，重新驱动 Cotton2K 模型，模拟干物质积累，每一层的 $PAI_{\%,i}$ 通过公式 \ref{eq:pai} 计算
\begin{equation}
    \label{eq:pai}
    PAI_{\%,i} = 1 - (1 - x_i^\alpha)^\beta
\end{equation}
$PAI_{\%,i}$ 是第 $i$ 层截获 $PAI$ 与最顶部冠层 $PAI$ 的比值，$x_i$ 是冠层深度的百分比，
研究中分 20 层，所以最顶层等于 0.05，最底层等于 1。$\alpha$ 和 $\beta$ 根据不同生长发育时期实际观测的每层 $PAI$ 和冠层顶部的 $PAI$ 确定，分段拟合。

首先，IRE 方法改进水分运移方程的上下边界条件，与根系吸水模型耦合，研究土体 100cm，厚度分层 5cm，水平方向间距 5cm。
其次，根据根长密度分布函数计算每个土层空间的根长密度，并使用 SWAP 模型推荐的方法计算潜在蒸发蒸腾量，分配到每一个土层空间。最后，以每小时时间步长应用 IRE 方法离散土壤蒸发、根系吸水和水盐运移过程。
具体步骤如下：


潜在作物蒸腾与土壤蒸发的计算如公式\ref{eq:E_p}和公式\ref{eq:T_p}
\begin{equation}
    \label{eq:T_p}
    T_p = \frac{
        (1 - W_{frac}) \{ V_c \frac{\Delta_v}{\lambda_w} (R_n - G) + \frac{p_1 \rho_a C_a}{\lambda_w} (\frac{e_{sat} - e_a}{r_{a,can}}) \}
    }{
        \Delta_v + \gamma_a(1 + \frac{ r_{s,\min} }{ r_{a,can} LAI_{eff} })
    }
\end{equation}
\begin{equation}
    \label{eq:E_p}
    E_p = \frac{
        (1 - V_c) \frac{\Delta_v}{\lambda_w} (R_n - G)
        + \frac{p_1 \rho_a C_a}{\lambda_w} (\frac{e_{sat} - e_a}{r_{a,can}})
    }{
        \Delta_v + \gamma_a (1 + \frac{r_{soil}}{r_{a,soil}})
    }
\end{equation}

\subsection{模型参数化}
本文采用 2019-2020 连续 2 年的棉花实验数据对 Cotton2K 模型进行参数化。
其中作物生长参数如叶面积指数 (LAI)，株高，干物质积累和主茎节数通过实验得到。
土壤参数如土壤水分、盐分初始值由实验得到；饱和导水率，Van-Genuchten
公式参数 $(\alpha, \beta)$ 等参数由率定得到；气象参数取自阿拉尔气象站；
作物参数和水分胁迫参数由率定得到。

\section{多目标优化}
NSGA-III 的基本框架类似于原始的 NSGA-II 算法 \cite{NSGA2}，其选择运算符有重大变化。
但是，与 NSGA-II 不同的是， NSGA-III 中种群成员间多样性的维持是通过提供和自适应更新一些分布良好的参考点来帮助的。
为了完整起见，首先对原始的 NSGA-II 算法进行简要描述。
考虑 NSGA-II 算法的第 $t$ 代，假设这一代的父代种群为 $P_t$，其规模为 $N$ ，而由 $P_t$ 产生的子代种群为 $Q_t$，有 $N$ 个成员。
第一步是从结合的亲代和子代种群 $R_t = P_t \cup Q_t$（大小为 $2N$ ）中选择最好的 $N$ 个成员，从而能够保留亲代种群的精英成员。
为了实现这一目标，首先根据不同的非同源等级（$F_1$、$F_2$等）对组合群体 $R_t$ 进行排序。
然后，从 $F_1$ 开始，每次选择一个非同化水平来构建一个新的种群 $S_t$ ，直到St的大小等于 $N$ 或首次超过 $N$。
因此，从第 $(l+1)$ 级开始的所有解决方案都被拒绝在组合群体 $R_t$ 中。
在这种情况下，只有那些能使第l层前面的多样性最大化的解决方案被选择。
在 NSGA-II 中，这是通过一个计算效率高但近似的利基 (niche) 保护算子来实现的，该算子将每个最后一级成员的拥挤距离计算为两个相邻解决方案之间的客观归一化距离之和。
此后，具有较大拥挤距离值的解决方案被选中。
在 NSGA-III 中，用以下方法取代拥挤距离算子。

\subsection{将种群按非支配等级分类}

上述利用通常的支配原则\cite{chankong1983}识别非支配前沿的程序也被用于NSGA-III。
如果 $|St|=N$ ，则不需要进一步的操作，下一代从$P_t+1=S_t$开始。
对于 $|St|>N$，从一到 ($l-1$) 个前沿的成员已经被选中，即 $P_{t+1}= \cup_{i=1}^{l-1} F_i$ ，剩下的 $(K=N-|Pt+1|)$ 人口成员从最后的前沿 $F_l$ 中选择。
在下面几个小节中描述其余的选择过程。

\subsection{确定超平面上的参考点}

如前所述， NSGA-III 使用一组预定义的参考点来确保获得的解决方案的多样性。
所选择的参考点既可以以结构化的方式预定义，也可以由用户优先提供。
在没有任何偏好信息的情况下，可以采用任何预定义的结构化的参考点放置，但实践中常常使用 Das和Dennis的\cite{das&dennis2000}系统方法1，
将点放置在一个归一化的超平面--一个 ($M-1$) 维的单位单纯线上，该平面对所有目标轴的倾斜度相同，在每个轴的截距为1。
如果沿每个目标考虑 $p$ 个划分，那么在一个 $M$ 目标问题中，参考点的总数 ($H$) 由以下公式给出

\begin{equation}\label{eq:H}
    H = \begin{pmatrix}
        M + p - 1 \\
        p
    \end{pmatrix}
\end{equation}

例如，在一个三目标问题 ($M = 3$) 中，参考点被创建在一个三角形上，顶点在 $(1, 0, 0)$，$(0, 1, 0)$，$(0, 0, 1)$。
如果为每个目标轴选择四个分部 $(p=4)$, $H = (\begin{smallmatrix}
        3+4-1\\
        4
    \end{smallmatrix})$ 或 $15$ 个参考点将被创建。
为清楚起见，这些参考点显示在图 \ref{fig:refPoints} 中。
在 NSGA-III 中，除了强调非支配性的解决方案外，还强调在某种意义上与这些参考点中的每一个相关的人口成员。
由于上述创建的参考点广泛分布在整个归一化超平面上，因此获得的解决方案也可能广泛分布在帕累托最优前沿或附近。
在用户提供一组首选参考点的情况下，理想情况下，用户可以在归一化超平面上标记 $H$ 个点，或者为此给出任何 $H$ 个 $M$ 维的向量。
所提出的算法有可能找到与所提供的参考点相对应的接近帕累托最优的解决方案，从而使这种方法可以更多地从决策和多目标优化的综合应用角度来使用。
该程序在算法 \ref{alg:NSGA3} 中提出。
\begin{figure}
    \tdplotsetmaincoords{75}{135}
    \centering
    \begin{tikzpicture}
        [tdplot_main_coords,
            axis/.style={-stealth,thick},
            vector/.style={-stealth,very thick}]
        \draw[axis] (0,0,0) -- (5,0,0) node[anchor=east]{$f1$};
        \draw[axis] (0,0,0) -- (0,5,0) node[anchor=west]{$f2$};
        \draw[axis] (0,0,0) -- (0,0,5) node[anchor=west]{$f3$};
        \filldraw[fill=gray,fill opacity=0.8] (0,0,4)--(4,0,0)--(0,4,0)--cycle;
        \draw[-stealth,very thick] (0,3,3) node[anchor=west]{归一化平面} -- (0.5,1.25,2.25);
        \draw[-stealth,very thick] (2,3,0) node[anchor=west]{理想点} -- (0,0,0);
        \fill(4,0,0) circle (2pt) node[anchor=south] {1};
        \fill(3,1,0) circle (2pt);
        \fill(3,0,1) circle (2pt);
        \fill(2,2,0) circle (2pt);
        \fill(2,1,1) circle (2pt);
        \fill(2,0,2) circle (2pt);
        \fill(1,3,0) circle (2pt);
        \fill(1,2,1) circle (2pt);
        \fill(1,1,2) circle (2pt);
        \fill(1,0,3) circle (2pt);
        \draw[-stealth,very thick] (3,0,4) node[anchor=east]{参考点} -- (1,0,3);
        \fill(0,4,0) circle (2pt) node[anchor=south] {1};
        \fill(0,3,1) circle (2pt);
        \fill(0,2,2) circle (2pt);
        \fill(0,1,3) circle (2pt);
        \fill(0,0,4) circle (2pt) node[anchor=south east] {1};
        \draw[vector] (0,0,0) -- (3,1.5,1.5) node[anchor=south]{参考向量};
    \end{tikzpicture}
    \caption{15个结构化参考点显示在归一化参考平面上，适用于$p=4$的三目标问题}\label{fig:refPoints}
\end{figure}


\begin{algorithm}\label{alg:NSGA3}
    \caption{NSGA-III 第 t 代的过程}
    \KwIn{$H$ 构造的参考点 $Z^s$ 或提供的目标点 $Z^a$, 父代种群 $P_t$}
    \KwOut{$P_{t+1}$}

    $S_t = \emptyset, i = 1$\\
    $Q_t$ = 重组+变异($P_t$)\\
    $R_t = P_t \cup Q_t$\\
    $(F_1, F_2, \dots)$ = 非支配排序($R_t$)\\
    \Repeat{$|S_t \ge N|$}{$S_t = S_t \cup F_i$ 且 $i = i + 1$}
    包含父代的 Pareto 前沿: $F_l = F_i$\\
    \eIf{$|S_t| = N$}{
    $P_{t+1} = S_t$, break
    }{
    $P_{t+1} = \cup^{l-1}_{j=1} F_j$\\
    从 $F_l$ 中选点: $K = N - |P_{t+1}|$\\
    归一化目标并创建参考集 $Z^r$: $\mathtt{Normalize}(\mathbf{f}^n, S_t, Z^r, Z^s, Z^a)$\\
    将 $S_t$ 的每个成员 $\mathbf{s}$ 与参考点相关联: $[\pi(\mathbf{s}), d(\mathbf{s})] =\mathtt{Associate}(S_t, Z^r)$
    \tcc{$\pi(\mathbf{s})$: 最近参考点, $d$: $\mathbf{s}$ 与 $\pi(\mathbf{s})$ 之间的距离}
    计算参考点的利基 (niche) 数 $j \in Z^r$: $\rho_j = \sum_{\mathbf{s}\in S_t/F_l}((\pi(\mathbf{s})) ? 1 : 0 )$\\
    一次从 $F_l$ 选取 $K$ 个成员构建 $P_{t+1}$: $\mathtt{Niching}(K, \rho_j, \pi, d, Z^r, F_l, P_{t+1})$
    }
\end{algorithm}
\subsection{种群成员的适应性归一化}
首先，$S_t$种群的理性点是由在$\cup_{\tau=0}^t S_{\tau}$中的每个目标函数$i =1,2,\dots,M$的最小值 ($z_i^{\min}$) 通过构建理想点%
$\overline{z} = (z_1^{\min}, z_2^{\min},\dots,z_M^{\min})$ 来确定的。%
然后，$S_t$ 的每个目标值通过用$z_i^{\min}$减去目标$f_i$来翻译，这样，翻译后的 $S_t$ 的理想点就成为一个零矢量。%
接着，通过寻找使相应的成就标化函数 (由$f'_i(\mathbf{x}) = f_i(\mathbf{x}) - z_i^{\min}$和接近第$i$个目标轴的权重向量形成) 最小的解 $(x \in S_t)$，%
来确定每个（第$i$个）目标轴中的极端点 ($z^{i,\max}$)。
随后，这些$M$个极端向量被用来构成一个$M$维的超平面。%
接下来可以计算出第$i$个目标轴和线性超平面的截距$a_i$（见图\ref{fig:formingHyperPlane}）。%
\begin{figure}
    \tdplotsetmaincoords{45}{120}
    \centering
    \begin{tikzpicture}
        [tdplot_main_coords,
            cube/.style={very thick,black},
            grid/.style={very thin,gray},
            axis/.style={-stealth,thick},
            vector/.style={-stealth,very thick},
            annotation/.style={fill=white,font=\footnotesize,inner sep=1pt}]
        \draw[axis] (0,0,0) -- (6,0,0) node[anchor=east]{$f'_1$};
        \draw[axis] (0,0,0) -- (0,6,0) node[anchor=west]{$f'_2$};
        \draw[axis] (0,0,0) -- (0,0,6) node[anchor=west]{$f'_3$};
        \foreach \coo in {2,4}
            {
                \draw (\coo, 0, 0) node[anchor=east] {\fpeval{\coo/2}} -- (\coo, 0.25, 0);
                \draw (0, \coo, 0) node[anchor=south] {\fpeval{\coo/2}} -- (0.25, \coo, 0);
                \draw (0, 0, \coo) node[anchor=east] {\fpeval{\coo/2}} -- (0, 0.25, \coo);
            }
        \foreach \coo in {1,3,5}
            {
                \draw (\coo, 0, 0) -- (\coo, 0.125, 0);
                \draw (0, \coo, 0) -- (0.125, \coo, 0);
                \draw (0, 0, \coo) -- (0, 0.125, \coo);
            }
        \draw[thick] (0,0,5.2)--(4.4,0,0)--(0,3.5,0)--cycle;
        \draw (4.4,0,0)--(4.4,-1,0);
        \draw (0,0,0)--(0,-1,0);
        \draw (0,0,5.2)--(0,-1,5.2);
        \draw (0,0,0)--(-1,0,0);
        \draw (0,3.5,0)--(-1,3.5,0);
        \draw[arrows=<->] (0,-0.8,0)--(2.2,-0.8,0) node[annotation] {$a_1$}--(4.4,-0.8,0);
        \draw[arrows=<->] (-0.8,0,0)--(-0.8,1.75,0) node[annotation] {$a_2$}--(-0.8,3.5,0);
        \draw[arrows=<->] (0,-0.8,0)--(0,-0.8,2.6) node[annotation] {$a_3$}--(0,-0.8,5.2);
        \fill(\fpeval{4.4*0.1},\fpeval{3.5*0.1},\fpeval{5.2*0.8}) circle (2pt);
        \fill(\fpeval{4.4*0.05},\fpeval{3.5*0.8},\fpeval{5.2*0.15}) circle (2pt);
        \fill(\fpeval{4.4*0.8},\fpeval{3.5*0.1},\fpeval{5.2*0.1}) circle (2pt);
        \draw[dash pattern=on 5pt off 5pt] (\fpeval{4.4*0.1},\fpeval{3.5*0.1},\fpeval{5.2*0.8}) node[anchor=south west] {$z^{3,\max}$}--(\fpeval{4.4*0.05},\fpeval{3.5*0.8},\fpeval{5.2*0.15}) node[anchor=south west] {$z^{2,\max}$}--(\fpeval{4.4*0.8},\fpeval{3.5*0.1},\fpeval{5.2*0.1}) node[anchor=west] {$z^{1,\max}$}--cycle;
    \end{tikzpicture}
    \caption{以三目标问题为例，计算截距，然后从极端点形成超平面的程序}\label{fig:formingHyperPlane}
\end{figure}
要特别注意处理退化的情况和非负的截距。%
再然后，目标函数可以被规范化为
\begin{equation}\label{eq:normalize}
    f_i^n (\mathbf{x})= \frac{f_i'(x)}{a_i},\ \mathrm{for}\ i = 1, 2, \dots, M.
\end{equation}
请注意，现在每个归一化目标轴的截点都在$f_i^n = 1$，用这些截点构建的超平面将使$\sum^M_{i=1} f_i^n = 1$。
在结构化参考点 (其中有$H$个) 的情况下，用Das和Dennis\cite{das&dennis1998}的方法计算的原始参考点已经位于这个归一化的超平面上。%
在用户偏爱参考点的情况下，参考点只需使用 \ref{eq:normalize} 映射到上述构建的标准化超平面上。%
由于归一化程序和超平面的创建是在每一代使用从模拟开始时发现的极端点来完成的，%
因此 NSGA-III 程序在每一代都能自适应地保持 $S_t$ 成员所跨越空间的多样性。%
这使得 NSGA-III 能够解决具有帕累托最优前沿的问题，其目标值可以有不同的比例。%
该程序也在算法 \ref{alg:normalize} 中进行了描述。
\begin{algorithm}
    \caption{$\mathtt{Normalize}(\mathbf{f}^n, S_t, Z^r, Z^s, Z^a)$过程}\label{alg:normalize}
    \KwIn{$S_t$, $Z^s$ (构造点) 或 $Z^a$ (提供点)}
    \KwOut{$\mathbf{f}^n$, $Z^r$ (归一化的超平面上的参考点)}

    \For{$j = 1 \mathbf{to} M$}{
    计算理想点: $z_j^{\min} = \min_{\mathbf{S}\in S_t} f_j(s)$
    翻译目标: $f_j'(\mathbf{s}) = f_j(\mathbf{s}) - z_j^{\min} \quad \forall \mathbf{s} \in S_t$
    计算极点: $(\mathbf{z}^{j,\max}, j = 1, \dots, M)$ of $S_t$
    }

    计算截点 $a_j$ 对 $j = 1, \dots, M$
    使用公式 \ref{eq:normalize} 归一化目标 ($\mathbf{f}^n$)

    \eIf{是否提供 $Z^a$}{
        使用公式 \ref{eq:normalize} 将每个（吸气）点映射到归一化的超平面上，并将这些点保存在集合 $Z^r$ 中。
    }{
        $Z^r=Z^s$
    }
\end{algorithm}
\subsection{关联操作}
在根据目标空间中$S_t$成员的范围自适应地对每个目标进行归一化后，需将每个群体成员与一个参考点联系起来。%
为此，通过连接参考点和原点，在超平面上定义一条对应于每个参考点的参考线。%
然后，计算$S_t$的每个人口成员与每条参考线的垂直距离。%
在归一化目标空间中，参考线最接近人口成员的参考点被认为与该人口成员相关。%
这在图\ref{fig:associate}中得到了说明。该程序在算法\ref{alg:associate}中提出。
\begin{algorithm}
    \caption{$\mathtt{Associate}(S_t,Z^r)$ 过程}\label{alg:associate}
    \KwIn{$Z^r, S_t$}
    \KwOut{$\pi(\mathbf{s} \in S_t), d(\mathrm{s} \in S_t)$}
    \ForEach{每个参考点 $\mathbf{z} \in Z^r$}{
        计算参考线 $\mathbf{w} = \mathbf{z}$
    }
    \ForEach{$\mathbf{s} \in S_t$}{
    \ForEach{$\mathbf{w} \in Z^r$}{
        计算 $d^{\bot}(\mathbf{s}, \mathbf{w}) = \parallel (\mathbf{s} - \mathbf{w}^T \mathbf{sw} /\parallel \mathbf{w} \parallel^2) \parallel $
    }
    $\pi(\mathbf{s}) = \mathbf{w} : \mathrm{argmin}_{\mathbf{w} \in Z^r} d^{\bot}(\mathbf{s}, \mathbf{w})$
    $d(\mathbf{s}) = d^{\bot}(\mathbf{s},\pi(\mathbf{s}))$
    }
\end{algorithm}
\begin{figure}
    \tdplotsetmaincoords{45}{150}
    \centering
    \begin{tikzpicture}
        [tdplot_main_coords,
            cube/.style={very thick,black},
            grid/.style={very thin,gray},
            axis/.style={-stealth,thick},
            vector/.style={-stealth,very thick},
            annotation/.style={fill=white,font=\footnotesize,inner sep=1pt},
            refPoints/.style={fill=gray},
            sample/.style={fill=black},
            dashedLine/.style={dash pattern=on 5pt off 5pt}]
        \draw (0,6,0) -- (3,6,0) node[anchor=north west]{$f'_1$} -- (6,6,0);
        \draw (6,0,0) -- (6,3,0) node[anchor=east]{$f'_2$} -- (6,6,0);
        \draw (6,0,0) -- (6,0,3) node[anchor=west]{$f'_3$} -- (6,0,6);
        \foreach \tick in {0,0.5,1,1.5} {
                \draw (\fpeval{0+\tick*4},6,0) -- (\fpeval{0+\tick*4},6.25,0) node[anchor=north west] {\tick};
                \draw (6,\fpeval{0+\tick*4},0) -- (6.25,\fpeval{0+\tick*4},0) node[anchor=north east] {\tick};
                \draw (6,0,\fpeval{0+\tick*4}) -- (6,-0.25,\fpeval{0+\tick*4}) node[anchor=south east] {\tick};
            }
        \filldraw[fill=gray!30,fill opacity=0.6] (0,0,4)--(4,0,0)--(0,4,0)--cycle;
        \fill[refPoints](4,0,0) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (5,0,0);
        \fill[refPoints](\fpeval{8/3},\fpeval{4/3},0) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (\fpeval{8/3 * 5 / sqrt(80/9)},\fpeval{4/3 * 5 / sqrt(80/9)},0);
        \fill[refPoints](\fpeval{4/3},\fpeval{8/3},0) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (\fpeval{4/3 * 5 / sqrt(80/9)},\fpeval{8/3 * 5 / sqrt(80/9)},0);
        \fill[refPoints](0,4,0) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (0,5,0);
        \fill[refPoints](\fpeval{8/3},0,\fpeval{4/3}) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (\fpeval{8/3 * 5 / sqrt(80/9)},0,\fpeval{4/3 * 5 / sqrt(80/9)});
        \fill[refPoints](\fpeval{4/3},\fpeval{4/3},\fpeval{4/3}) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (\fpeval{4/3 * 5 / sqrt(16/3)},\fpeval{4/3 * 5 / sqrt(16/3)},\fpeval{4/3 * 5 / sqrt(16/3)});
        \fill[refPoints](0,\fpeval{8/3},\fpeval{4/3}) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (0,\fpeval{8/3 * 5 / sqrt(80/9)},\fpeval{4/3 * 5 / sqrt(80/9)});
        \fill[refPoints](0,\fpeval{4/3},\fpeval{8/3}) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (0,\fpeval{4/3 * 5 / sqrt(80/9)},\fpeval{8/3 * 5 / sqrt(80/9)});
        \fill[refPoints](\fpeval{4/3},0,\fpeval{8/3}) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (\fpeval{4/3 * 5 / sqrt(80/9)},0,\fpeval{8/3 * 5 / sqrt(80/9)});
        \fill[refPoints](0,0,4) circle (2pt);
        \draw[dashedLine] (0,0,0) -- (0,0,5);

        % sample points
        \fill[sample](0.5,0,4) circle (2pt);
        \draw (0.5,0,4)--(0.0,0.0,4.0);
        \fill[sample](0.6,3.9,2.1) circle (2pt);
        \draw (0.6,3.9,2.1)--(0.0,3.96,1.98);
        \fill[sample](1,4,1) circle (2pt);
        \draw (1,4,1)--(1.8,3.6,0.0);
        \fill[sample](1.2,1.2,3.6) circle (2pt);
        \draw (1.2,1.2,3.6)--(1.68,0.0,3.36);
        \fill[sample](4,1,2) circle (2pt);
        \draw (4,1,2)--(4.0,0.0,2.0);
        \fill[sample](3.2,1,3) circle (2pt);
        \draw (3.2,1,3)--(3.76,0.0,1.88);
        \fill[sample](3.2,1.8,2.4) circle (2pt);
        \draw (3.2,1.8,2.4)--(2.46667,2.46667,2.46667);
    \end{tikzpicture}
    \caption{展示了将种群成员与参考点关联}\label{fig:associate}
\end{figure}

\subsection{利基 (niche) 保护操作}
值得注意的是，一个参考点可以有一个或多个种群成员与之相关联，或者不需要有任何种群成员与之相关联。%
计算 $P_{t+1}=S_t/F_l$ 中与每个参考点相关的种群成员的数量。%
第 $j$ 个参考点的这个利基计数记作 $\rho_j$。%
首先，确定参考点集 $J_{\min} = \{j : \mathrm{argmin}_j \rho_{j}\}$ 具有最小$\rho_j$。%
在有多个这样的参考点的情况下，随机选择一个 ($\overline{j} \in J_{\min}$)。%
如果 $\rho_{\overline{j}}= 0$（意味着参考点 $\overline{j}$ 没有相关的$P_{t+1}$成员），在集合$F_l$中的 $\overline{j}$ 可能有两种情况。%
首先， $F_l$ 中存在一个或多个与参考点 $\overline{j}$相关的成员。%
在这种情况下，与参考线垂直距离最短的成员被添加到 $P_{t+1}$。%
然后，参考点 $\overline{j}$ 的计数 $\rho_{\overline{j}}$递增1。%
第二，前面的$F_l$没有任何与参考点 $\overline{j}$ 相关的成员。%
在这种情况下，参考点被排除在当前一代的进一步考虑之外。%
在 $\rho_{\overline{j}} \ge 1$ 的情况下（意味着$S_t/F_l$中已经有一个与参考点相关的成员存在），如果存在的话，从前面$F_l$中随机选择一个与参考点$\overline{j}$相关的成员被添加到$P_{t+1}$。%
然后，$\rho_{\overline{j}}$的计数被增加1。%
利基计数更新后，该程序共重复K次，以填补 $P_{t+1}$ 的所有空闲人口槽。%
该程序在算法\ref{alg:niche}中提出。
\begin{algorithm}
    \caption{$\mathtt{Niching}(K, \rho_j, \pi, d, Z^r, F_l, P_{t+1})$过程}\label{alg:niche}
    \KwIn{$K, \rho_j, \pi(\mathbf{s} \in S_t), d(\mathbf{s} \in S_t), Z^r, F_l$}
    \KwOut{$P_{t+1}$}
    $k = 1$
    \While{$k \le K$}{
    $J_{\min} = \{ j:\mathrm{agrmin}_{j \in Z^r} \rho_j \}$
    $\overline{j}  = \mathrm{random}(J_{\min})$
    $I_{\overline{j}} = \{ s: \pi(\mathbf{s}) = \overline{j}, s \in F_l \}$
    \eIf{$I_{\overline{j}} \neq \emptyset$}{
    \eIf{$\rho_{\overline{j}} = 0$}{
    $P_{t+1} = P_{t+1} \cup ( \mathbf{s}: \mathrm{argmin}_{\mathbf{S} \in I_{\overline{j}}} d(\mathbf{s}) )$
    }{
    $P_{t+1} = P_{t+1} \cup \mathrm{random}(I_{\overline{j}})$
    }
    $\rho_{\overline{j}} = \rho_{\overline{j}} + 1, F_l = F_l \setminus \mathbf{s}$
    $k = k + 1$
    }{
    $Z^r = Z^r / \{ \overline{j} \}$
    }
    }
\end{algorithm}

\subsection{创造后代群体的遗传操作}
$P_{t+1}$ 形成后，再通过应用通常的遗传算子来创建一个新的子代群体 $Q_{t+1}$。%
在NSGA-III中，已经对解决方案进行了仔细的精英选择，并试图通过强调最接近每个参考点参考线的解决方案来保持解决方案的多样性。%
此外，为了达到快速计算的目的，设定 $N$ 几乎等于 $H$，从而期望在每个参考点对应的帕累托最优前线附近进化出一个群体成员。%
由于所有这些原因，在处理仅有箱体约束的问题时，没有采用 NSGA-III 的任何明确的繁殖操作。%
群体 $Q_{t+1}$ 是通过从 $P_{t+1}$ 中随机挑选父母，应用通常的交叉和变异操作来构建。%
然而，为了使后代的解更接近父代的解，建议在SBX运算中使用一个相对较大的分布指数值，从而使后代接近其父代。

\subsection{NSGA-III 中一代的计算复杂度}
对具有 $M$ 维目标向量的 $2N$ 大小的群体进行非支配性排序（算法\ref{alg:NSGA3}的第4行）需要 $O(N \log ^{M-2} N)$次计算\cite{kung1975}。%
算法\ref{alg:normalize}第2行中的理想点的识别总共需要 $O(MN)$ 次计算。%
目标的转换（第3行）需要 $O(MN)$ 次计算。%
然而，识别极端点（第4行）需要 $O(M^2N)$次计算。%
确定截距（第6行）需要一个大小为 $M \times M$ 的矩阵反转，需要 $O(M^3)$ 次运算。%
此后，对最大的 $2N$ 个人口成员进行归一化（第7行）需要 $O(N)$ 次计算。%
算法\ref{alg:normalize}的第8行需要 $O(MH)$次计算。%
算法\ref{alg:associate}中把最多2N个种群成员与H个参考点联系起来的所有操作都需要 $O(MNH)$计算。%
此后，在算法\ref{alg:niche}的排队程序中，第3行将需要 $O(H)$ 次比较。假设 $L=|F_l|$，第5行需要 $O(L)$ 个检查。%
第8行在最坏的情况下需要 $O(L)$ 次计算。其他操作的复杂度较小。%
然而，在 $\mathtt{Niching}$ 算法中，上述计算最多需要执行L次，因此需要更大的$O(L^2)$或$O(LH)$计算。%
在最坏的情况下（$S_t = F_1$，即第一个非支配阵线超过种群大小），$L \le 2N$。%
在我们所有的模拟中，我们使用了$N \approx H$，通常 $N > M$。%
考虑到上述所有的考虑和计算，NSGA-III一代的总体最坏情况下的复杂度为 $O(N^2 \log^{M-2} N)$ 或 $O(N^2M)$，以较大者为准。

\subsection{NSGA-III 的无参数特性}
与NSGA-II一样，NSGA-III算法不需要设置任何新的参数，除了通常的GA参数，如种群大小、终止参数、交叉和变异概率及其相关参数。%
参考点的数量 $H$ 不是一个算法参数，因为这与期望的权衡点的数量直接相关。%
人口规模 $N$ 取决于 $H$，因为$N \approx H$。%
参考点的位置同样取决于用户对所获得的解决方案中的偏好信息。
